'''
 * file Vision-Espejo.py
 * author Jared Aldana Palacios 
 * brief Source file for the OpenMV
 * date 2026-02-12
'''

import sensor
import time
import pyb
import math
from pyb import UART

# UART Communication
UART_PORT = 3
UART_BAUDRATE = 115200


THRESHOLD_BALL = (23, 93, 20, 83, 87, -4)     
THRESHOLD_YELLOW_GOAL = (12, 18, 5, -9, -14, -3)  
THRESHOLD_BLUE_GOAL = (30, 63, -11, 8, 38, 15)  

# Reference center of the robot (Adjust to the center of the mirror)
X_CENTER = 144
Y_CENTER = 148

# Detection parameters
BALL_AREA_THRESHOLD = 20        
GOAL_AREA_THRESHOLD = 200       
GOAL_PIXELS_THRESHOLD = 100     

# Improved ball detection
MINIMUN_CLOSE_AREA = 100
MINIMUN_FAR_AREA = 4

# Dead zones to avoid vibrations (in degrees)
BALL_DEAD_ZONE = 5.0
BLUE_GOAL_DEAD_ZONE = 20.0
YELLOW_GOAL_DEAD_ZONE = 5.0

# Distance adjustments when object is far behind (>135° or <-135°)
BALL_DISTANCE_CORRECTION = 10.0
YELLOW_GOAL_DISTANCE_CORRECTION = -30.0
YELLOW_GOAL_MIN_DISTANCE = 10.0



# Camera configuration
CAMERA_EXPOSURE = 25000  
CAMERA_GAIN_CEILING = 16
CAMERA_BRIGHTNESS = 1
CAMERA_CONTRAST = -5
CAMERA_SATURATION = -6

# Delay between readings (in milliseconds) 
LOOP_DELAY = 50

# INITIALIZATION 

def initialize_camera():

    led = pyb.LED(1)
    led.on()
    time.sleep(1)
    led.off()
    
    sensor.reset()
    sensor.set_pixformat(sensor.RGB565)
    sensor.set_framesize(sensor.QVGA)  # 320x240
    
    print(" INITIALIZING CAMERA ")
    print("Gain Ceiling:", sensor.get_gain_db())
    print("Exposure:", sensor.get_exposure_us())
    
    sensor.skip_frames(time=500)
    
    sensor.set_auto_gain(False)
    sensor.set_gainceiling(CAMERA_GAIN_CEILING)
    sensor.set_auto_whitebal(False)
    sensor.set_auto_exposure(False, exposure_us=CAMERA_EXPOSURE)
    sensor.set_brightness(CAMERA_BRIGHTNESS)
    sensor.set_contrast(CAMERA_CONTRAST)
    sensor.set_saturation(CAMERA_SATURATION)
    
    sensor.set_hmirror(True)
    sensor.set_vflip(False)
    sensor.set_transpose(True)

def initialize_uart():

    uart = UART(UART_PORT, UART_BAUDRATE, timeout_char=0)
    uart.init(UART_BAUDRATE, bits=8, parity=None, stop=1)
    print("UART configured on port", UART_PORT, "at", UART_BAUDRATE, "baud\n")
    return uart

# OBJECT DETECTION 

def find_ball(img):

    blobs = img.find_blobs(
        [THRESHOLD_BALL], 
        area_threshold=BALL_AREA_THRESHOLD, 
        merge=True
    )
    
    valid_blobs = []
    
    if blobs:
        # Prioritize larger blobs and those closer to the center
        blobs = sorted(
            blobs,
            key=lambda BLOBS: (BLOBS.area(), -calculate_distance(BLOBS)),
            reverse=True
        )
        
        for blob in blobs:
            area = blob.area()
            circularity = blob.compactness()
            
            # Near ball
            if area >= MINIMUN_CLOSE_AREA and circularity > 0.3:
                valid = True
            # Far ball
            elif MINIMUN_FAR_AREA <= area < MINIMUN_CLOSE_AREA and circularity > 0.5:
                valid = True
            else:
                valid = False
            
            if valid:
            
                img.draw_rectangle(blob.rect(), color=(255, 255, 255))
                img.draw_cross(blob.cx(), blob.cy(), color=(255, 255, 255))

                if area >= MINIMUN_CLOSE_AREA :
                    radio = int((blob.w() + blob.h()) / 4)
                    img.draw_circle(blob.cx(), blob.cy(), radio, color=(255, 255, 255))
                
                valid_blobs.append(blob)
                break  
    
    return valid_blobs

def find_blue_goal(img):

    blobs = img.find_blobs(
        [THRESHOLD_BLUE_GOAL],
        pixels_threshold=GOAL_PIXELS_THRESHOLD,
        area_threshold=GOAL_AREA_THRESHOLD,
        merge=True
    )
    
    for blob in blobs:
        img.draw_rectangle(blob.rect(), color=(0, 255, 0))
        img.draw_cross(blob.cx(), blob.cy(), color=(0, 255, 0))
    
    return blobs

def find_yellow_goal(img):

    blobs = img.find_blobs(
        [THRESHOLD_YELLOW_GOAL],
        pixels_threshold=GOAL_PIXELS_THRESHOLD,
        area_threshold=GOAL_AREA_THRESHOLD,
        merge=True
    )
    
    for blob in blobs:
        img.draw_rectangle(blob.rect(), color=(0, 0, 255))
        img.draw_cross(blob.cx(), blob.cy(), color=(0, 0, 255))
    
    return blobs

# GEOMETRIC CALCULATIONS 

def calculate_distance(blob):

    dx = blob.cx() - X_CENTER
    dy = blob.cy() - Y_CENTER
    return math.sqrt(dx**2 + dy**2)

def calculate_angle(blob):

    dx = blob.cx() - X_CENTER
    dy = blob.cy() - Y_CENTER
    
    angle_rad = math.atan2(dy, dx)
    angle_deg = math.degrees(angle_rad)
    
    if angle_deg < 0.0:
        angle_deg = 360.0 + angle_deg
    
    angle_adjusted = -(angle_deg - 180.0)
    
    return angle_adjusted

def apply_dead_zone(angle, dead_zone):

    if -dead_zone < angle < dead_zone:
        return 0.0
    return angle

def correct_distance(distance, angle, correction, threshold_angle=135.0):

    if angle > threshold_angle or angle < -threshold_angle:
        return distance + correction
    return distance

# MAIN LOOP 

def main():

    initialize_camera()
    uart = initialize_uart()
    
    ball_distance = 0.0
    ball_angle = 0.0
    blue_goal_distance = 0.0
    blue_goal_angle = 0.0
    yellow_goal_distance = 0.0
    yellow_goal_angle = 0.0
    
    clock = time.clock()
    
    print(" STARTING DETECTION \n")
    
    while True:
        clock.tick()
        img = sensor.snapshot()
        
        img.draw_cross(X_CENTER, Y_CENTER, color=(255, 255, 255))
        
        # BALL DETECTION 
        ball_blobs = find_ball(img)
        if ball_blobs:
            blob = ball_blobs[0]
            ball_distance = calculate_distance(blob)
            ball_angle = calculate_angle(blob)
            
            ball_angle = apply_dead_zone(ball_angle, BALL_DEAD_ZONE)
            
            ball_distance = correct_distance(
                ball_distance, 
                ball_angle, 
                BALL_DISTANCE_CORRECTION
            )
        else:
            ball_distance = 0.0
            ball_angle = 0.0
        
        # BLUE GOAL DETECTION 
        blue_goal_blobs = find_blue_goal(img)
        if blue_goal_blobs:
            blob = blue_goal_blobs[0]
            blue_goal_distance = calculate_distance(blob)
            blue_goal_angle = calculate_angle(blob)
            
            blue_goal_angle = apply_dead_zone(
                blue_goal_angle, 
                BLUE_GOAL_DEAD_ZONE
            )
        else:
            blue_goal_distance = 0.0
            blue_goal_angle = 0.0
        
        # YELLOW GOAL DETECTION 
        yellow_goal_blobs = find_yellow_goal(img)
        if yellow_goal_blobs:
            blob = yellow_goal_blobs[0]
            yellow_goal_distance = calculate_distance(blob)
            yellow_goal_angle = calculate_angle(blob)
            
            yellow_goal_angle = apply_dead_zone(yellow_goal_angle, YELLOW_GOAL_DEAD_ZONE)
            
            yellow_goal_distance = correct_distance(
                yellow_goal_distance,
                yellow_goal_angle,
                YELLOW_GOAL_DISTANCE_CORRECTION
            )
            
            if yellow_goal_distance < YELLOW_GOAL_MIN_DISTANCE:
                yellow_goal_distance = YELLOW_GOAL_MIN_DISTANCE
        else:
            yellow_goal_distance = 0.0
            yellow_goal_angle = 0.0
        
        # SEND DATA VIA UART 
        data = "{:.1f} {:.1f} {:.1f} {:.1f} {:.1f} {:.1f}\n".format(
            ball_distance,
            ball_angle,
            blue_goal_distance,
            blue_goal_angle,
            yellow_goal_distance,
            yellow_goal_angle
        )
        
        print("Sending:", data.strip())
        uart.write(data)
        
        pyb.delay(LOOP_DELAY)

if __name__ == "__main__":
    main()